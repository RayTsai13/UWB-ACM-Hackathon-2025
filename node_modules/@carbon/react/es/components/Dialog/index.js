/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { extends as _extends } from '../../_virtual/_rollupPluginBabelHelpers.js';
import PropTypes from 'prop-types';
import React__default, { useRef, useEffect } from 'react';
import { usePrefix } from '../../internal/usePrefix.js';
import cx from 'classnames';
import { Close } from '@carbon/icons-react';
import { IconButton } from '../IconButton/index.js';
import { noopFn } from '../../internal/noopFn.js';

const unstable__Dialog = /*#__PURE__*/React__default.forwardRef((_ref, forwardRef) => {
  let {
    children,
    className,
    modal,
    onCancel = noopFn,
    onClick = noopFn,
    onClose = noopFn,
    onRequestClose = noopFn,
    open = false,
    ...rest
  } = _ref;
  const prefix = usePrefix();

  // This component needs access to a ref, placed on the dialog, to call the
  // various imperative dialog functions (show(), close(), etc.).
  // If the parent component has not passed a ref for forwardRef, forwardRef
  // will be null. A "backup" ref is needed to ensure the dialog's instance
  // methods can always be called within this component.
  const backupRef = useRef(null);
  const ref = forwardRef ?? backupRef;

  // Clicks on the backdrop of an open modal dialog should request the consuming component to close
  // the dialog. Clicks elsewhere, or on non-modal dialogs should not request
  // to close the dialog.
  function handleModalBackdropClick(e) {
    if (open && modal && e.target === ref.current) {
      onRequestClose(e);
    }
  }
  function handleClick(e) {
    handleModalBackdropClick(e);

    // onClick should always be called, no matter if the target is a modal
    // dialog, modal dialog backdrop, or non-modal dialog.
    onClick(e);
  }
  useEffect(() => {
    if (ref.current) {
      if (open) {
        if (modal) {
          // Display the dialog as a modal, over the top of any other dialogs
          // that might be present. Everything outside the dialog are inert
          // with interactions outside the dialog being blocked.
          ref.current.showModal();
        } else {
          // Display the dialog modelessly, i.e. still allowing interaction
          // with content outside of the dialog.
          ref.current.show();
        }
      } else {
        ref.current.close();
      }
    }
  }, [modal, open]);
  return /*#__PURE__*/React__default.createElement("dialog", _extends({}, rest, {
    className: cx(`${prefix}--dialog`, {
      [`${prefix}--dialog--modal`]: modal
    }, className),
    ref: ref,
    onCancel: onCancel,
    onClick: handleClick,
    onClose: onClose
  }), children);
});
unstable__Dialog.displayName = 'Dialog';
unstable__Dialog.propTypes = {
  /**
   * Provide children to be rendered inside of the Dialog
   */
  children: PropTypes.node,
  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: PropTypes.string,
  /**
   * Modal specifies whether the Dialog is modal or non-modal. This cannot be
   * changed while open=true
   */
  modal: PropTypes.bool,
  /**
   * Specify a handler for closing Dialog.
   * The handler should care of closing Dialog, e.g. changing `open` prop.
   */
  onRequestClose: PropTypes.func,
  /**
   * open initial state
   */
  open: PropTypes.bool
};
const DialogHeader = /*#__PURE__*/React__default.forwardRef((_ref2, ref) => {
  let {
    children,
    ...rest
  } = _ref2;
  const prefix = usePrefix();
  return /*#__PURE__*/React__default.createElement("div", _extends({
    className: `${prefix}--dialog__header`,
    ref: ref
  }, rest), children);
});
DialogHeader.propTypes = {
  /**
   * Provide the contents to be rendered inside of this component
   */
  children: PropTypes.node
};
const DialogControls = /*#__PURE__*/React__default.forwardRef((_ref3, ref) => {
  let {
    children,
    ...rest
  } = _ref3;
  const prefix = usePrefix();
  return (
    /*#__PURE__*/
    // @ts-ignore
    React__default.createElement("div", _extends({
      className: `${prefix}--dialog__header-controls`,
      ref: ref
    }, rest), children)
  );
});
DialogControls.propTypes = {
  /**
   * Provide children to be rendered inside of this component
   */
  children: PropTypes.node
};
const DialogCloseButton = /*#__PURE__*/React__default.forwardRef((_ref4, ref) => {
  let {
    onClick,
    ...rest
  } = _ref4;
  const prefix = usePrefix();
  return (
    /*#__PURE__*/
    // @ts-ignore
    React__default.createElement(IconButton, _extends({
      kind: "ghost",
      className: `${prefix}--dialog__close`,
      label: "Close",
      title: "Close",
      "aria-label": "Close",
      align: "left",
      onClick: onClick
    }, rest), /*#__PURE__*/React__default.createElement(Close, {
      size: 20,
      "aria-hidden": "true",
      tabIndex: "-1",
      className: `${prefix}--icon__close`
    }))
  );
});
DialogCloseButton.propTypes = {
  /**
   * Specify a click handler applied to the IconButton
   */
  onClick: PropTypes.func
};

export { DialogCloseButton, DialogControls, DialogHeader, unstable__Dialog };
